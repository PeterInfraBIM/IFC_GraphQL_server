
type Ref {
	type: String!
	ref: String!
}

type Root implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
}

type OwnerHistory implements Addressable {
	type: String!
	globalId: ID!
	owningUser: PersonAndOrganization
	owningApplication: Application
	changeAction: IfcChangeActionEnum
	creationDate: Int
}

type PersonAndOrganization {
	type: String!
	thePerson: Person
	theOrganization: Organization
}

type Person {
	type: String!
	id: String
	familyName: String
	givenName: String
}

type Organization {
	type: String!
	name: String
	description: String
}

type Application {
	type: String!
	applicationDeveloper: Organization
	version: String
	applicationFullName: String
	applicationIdentifier: String
}

type ObjectDefinition implements Addressable & IfcRoot & IfcObjectDefinition {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
}

type Object implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
}

type ProductRepresentation {
	representationsRef: [Ref!]
	representations: [ShapeRepresentation!]
}

type ShapeRepresentation {
	type: String!
	globalId: String!
	contextOfItemsRef: Ref
	representationIdentifier: String
	representationType: String
	items: [RepresentationItem!]
	ofProductRepresentation: [ProductRepresentation!]
}

union RepresentationItem = Polyline | ExtrudedAreaSolid

type Polyline {
	type: String!
	points: [CartesianPoint!]
}

type ExtrudedAreaSolid  {
	type: String!
	extrudedDirection: Direction
	depth: Float
	position: Axis2Placement3D
	sweptArea: ArbitraryClosedProfileDef
}

type ArbitraryClosedProfileDef {
	type: String!
	profileType: IfcProfileTypeEnum
	outerCurve: Polyline
}

type Product implements Addressable & IfcRoot & IfcObjectDefinition & IfcProduct {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	# Placement of the product in space
	objectPlacement: LocalPlacement
	# All Placements of the product in space 
	objectPlacements: [LocalPlacement!]
	# Reference to the representations of the product
	representation: ProductRepresentation
}

type Element implements Addressable & IfcRoot & IfcObjectDefinition & IfcProduct & IfcElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	hasAssociationsRef: [Ref!]
	hasAssociations: [RelAssociatesMaterial!]
	hasOpeningsRef: [Ref!]
	hasOpenings: [RelVoidsElement!]
	fillsVoidsRef: [Ref!]
	fillsVoids: [RelFillsElement!]
	containedInStructureRef: [Ref!]
}

type SpatialStructureElement implements Addressable 
										& IfcRoot 
										& IfcObjectDefinition 
										& IfcProduct 
										& IfcSpatialStructureElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	longName: String
	compositionType: IfcElementCompositionEnum
	containsElementsRef: [Ref!]
	containsElements: [RelContainedInSpatialStructure!]
	containsElementsDir: [Product!]
}

type RelAggregates implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatingObject: ObjectDefinition
	relatingObjectRef: Ref
	relatedObjects: [ObjectDefinition!]
	relatedObjectsRef: [Ref!]
}

type RelContainedInSpatialStructure implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatedElements: [Ref]
	relatingStructure: 	Ref
}

type RelAssociates implements Addressable & IfcRoot & IfcRelAssociates {
	type: String!
	globalId: ID!
	name: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	description: String
	relatedObjectsRef: [Ref!]
}

type RelAssociatesMaterial implements Addressable & IfcRoot & IfcRelAssociates {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatedObjectsRef: [Ref!]
	relatingMaterial: MaterialLayerSetUsage
}

type RelDefinesByProperties implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatedObjectsRef: [Ref!]
	relatedObjects: [Object!]
	relatingPropertyDefinitionRef: Ref
	relatingPropertyDefinition: PropertySet
}

type RelVoidsElement implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatingBuildingElementRef: Ref
	relatingBuildingElement: Element
	relatedOpeningElementRef: Ref
	relatedOpeningElement: OpeningElement
}

type RelFillsElement implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatingOpeningElementRef: Ref
	relatingOpeningElement: OpeningElement
	relatedBuildingElementRef: Ref
	relatedBuildingElement: Element
}

type RelSpaceBoundary implements Addressable & IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	relatingSpaceRef: Ref
	relatingSpace: Space
	relatedBuildingElementRef: Ref
	relatedBuildingElement: Element
}

type PropertySet implements IfcRoot {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	hasProperties: [Property!]
}

union Property = PropertySingleValue

union Value = RealValue | BooleanValue

type BooleanValue {
	type: String!
	booleanValue: Boolean
}

type RealValue {
	type: String!
	realValue: Float
}

type PropertySingleValue {
	type: String!
	name: String
	description: String
	nominalValue: Value
}

type MaterialLayerSetUsage {
	type: String!
	forLayerSet: MaterialLayerSet
	layerSetDirection: IfcLayerSetDirectionEnum
	directionSense: IfcDirectionSenseEnum
	offsetFromReferenceLine: Float
}

type MaterialLayerSet{
	type: String!
	materialLayers: [MaterialLayer!]
}

type MaterialLayer {
	type: String!
	material: Material
	layerThickness: Float!
}

type Material {
	type: String!
	name: String
}

type LocalPlacement {
	placementRelTo: LocalPlacement
	relativePlacement: Axis2Placement3D
}

type Axis2Placement3D {
	location: CartesianPoint
	axis: Direction
	refDirection: Direction
}

type CartesianPoint {
	coordinates: [Float]
}

type Direction {
	directionRatios: [Float]
}

type GeometricRepresentationContext implements Addressable {
	type: String!
	globalId: ID!
	contextType: String
	coordinateSpaceDimension: Int
	precision: Float
	worldCoordinateSystem: Axis2Placement3D
	representationsInContextRef: [Ref!]
	representationsInContext: [ShapeRepresentation!]
}

type Project implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
	representationContextsRef: [Ref!]
	representationContexts: [GeometricRepresentationContext!]
}

type Site implements Addressable & 
					 IfcRoot & 
					 IfcObjectDefinition &
					 IfcProduct &
					 IfcSpatialStructureElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	longName: String
	compositionType: IfcElementCompositionEnum
	containsElementsRef: [Ref!]
	containsElements: [RelContainedInSpatialStructure!]
	containsElementsDir: [Product!]
	refLatitude: [Float]
	refLongitude: [Float]
}

type Building implements Addressable & 
						 IfcRoot &
						 IfcObjectDefinition &
					 	 IfcProduct &
					 	 IfcSpatialStructureElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	longName: String
	compositionType: IfcElementCompositionEnum
	containsElementsRef: [Ref!]
	containsElements: [RelContainedInSpatialStructure!]
	containsElementsDir: [Product!]
}

# IfcBuildingStorey
type BuildingStorey 
	implements Addressable & IfcRoot & IfcObjectDefinition & IfcProduct & IfcSpatialStructureElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	longName: String
	compositionType: IfcElementCompositionEnum
	containsElementsRef: [Ref!]
	containsElements: [RelContainedInSpatialStructure!]
	containsElementsDir: [Product!]
	elevation: Float
}

type Space implements Addressable & IfcRoot & IfcObjectDefinition & IfcProduct & IfcSpatialStructureElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	representation: ProductRepresentation
	longName: String	
	compositionType: IfcElementCompositionEnum
	containsElementsRef: [Ref!]
	containsElements: [RelContainedInSpatialStructure!]
	containsElementsDir: [Product!]
	interiorOrExteriorSpace: IfcInternalOrExternalEnum
	boundedByRef: [Ref!]
	boundedBy: [RelSpaceBoundary!]
	boundedByDir: [Element!]
}

# IfcWallStandardCase
type WallStandardCase implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject & IfcProduct & IfcElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
	representation: ProductRepresentation
	hasAssociationsRef: [Ref!]
	hasAssociations: [RelAssociatesMaterial!]
	hasOpeningsRef: [Ref!]
	hasOpenings: [RelVoidsElement!]
	fillsVoidsRef: [Ref!]
	fillsVoids: [RelFillsElement!]
	containedInStructureRef: [Ref!]
}

# IfcOpeningElement
type OpeningElement implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject & IfcProduct & IfcElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
	representation: ProductRepresentation
	hasAssociationsRef: [Ref!]
	hasAssociations: [RelAssociatesMaterial!]
	hasOpeningsRef: [Ref!]
	hasOpenings: [RelVoidsElement!]
	fillsVoidsRef: [Ref!]
	fillsVoids: [RelFillsElement!]
	containedInStructureRef: [Ref!]
}

# IfcDoor
type Door implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject & IfcProduct & IfcElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
	representation: ProductRepresentation
	hasAssociationsRef: [Ref!]
	hasAssociations: [RelAssociatesMaterial!]
	hasOpeningsRef: [Ref!]
	hasOpenings: [RelVoidsElement!]
	fillsVoidsRef: [Ref!]
	fillsVoids: [RelFillsElement!]
	containedInStructureRef: [Ref!]
	overallHeight: Float
	overallWidth: Float
}

type StairFlight implements Addressable & IfcRoot & IfcObjectDefinition & IfcObject & IfcProduct & IfcElement {
	type: String!
	globalId: ID!
	name: String
	description: String
	ownerHistoryRef: Ref
	ownerHistory: OwnerHistory
	# is decomposed by [reference]
	isDecomposedByRef: [Ref!]
	# is decomposed by [objectified relation]
	isDecomposedBy: [RelAggregates!]
	# is decomposed by [directly linked]
	isDecomposedByDir: [ObjectDefinition!]
	# decomposes [reference]
	decomposesRef: [Ref!]
	# decomposes [objectified relation]
	decomposes: [RelAggregates!]
	# decomposes [directly linked]
	decomposesDir: [ObjectDefinition!]
	objectPlacement: LocalPlacement
	objectPlacements: [LocalPlacement!]
	isDefinedByRef: [Ref!]
	isDefinedBy: [RelDefinesByProperties!]
	representation: ProductRepresentation
	hasAssociationsRef: [Ref!]
	hasAssociations: [RelAssociatesMaterial!]
	hasOpeningsRef: [Ref!]
	hasOpenings: [RelVoidsElement!]
	fillsVoidsRef: [Ref!]
	fillsVoids: [RelFillsElement!]
	containedInStructureRef: [Ref!]
}

type Query {
	# Get all Root objects
	allRoots: [Root]
	# Get all ObjectDefinition objects
	allObjectDefinitions: [ObjectDefinition]
	# Get all Object objects
	allObjects: [Object]
	# Get all Product objects
	allProducts: [Product]
	# Get all SpatialStructureElement objects
	allSpatialStructureElements: [SpatialStructureElement]
	# Get all OpeningElement objects
	allOpeningElements: [OpeningElement]
	# Get all Project objects
	allProjects: [Project]
	# Get all Site objects
	allSites: [Site]	
	# Get all Building objects
	allBuildings: [Building]	
	# Get one Building object
	oneBuilding(globalId: String!): Building
	# Get all BuildingStorey objects
	allBuildingStoreys: [BuildingStorey]
	# Get one BuildingStorey object
	oneBuildingStorey(globalId: String!): BuildingStorey
	# Get all Space objects
	allSpaces: [Space]
	# Get one Space object
	oneSpace(globalId: String!): Space
	# Get all RelAggregates objects
	allRelAggregates: [RelAggregates]
	# Get all RelContainedInSpatialStructure objects
	allRelContainedInSpatialStructures: [RelContainedInSpatialStructure]
	# Get all RelAssociates objects
	allRelAssociates: [RelAssociates]
	# Get all RelAssociatesMaterial objects
	allRelAssociatesMaterials: [RelAssociatesMaterial]
	# Get all RelDefinesByProperties objects
	allRelDefinesByProperties: [RelDefinesByProperties]
	# Get all RelVoidsElement objects
	allRelVoidsElements: [RelVoidsElement]
	# Get all RelFillsElement objects
	allRelFillsElements: [RelFillsElement]
	# Get all RelSpaceBoundary objects
	allRelSpaceBoundaries: [RelSpaceBoundary]
	# Get one RelSpaceBoundary object
	oneRelSpaceBoundary(globalId: String!): RelSpaceBoundary
	# Get all WallStandardCase objects
	allWallStandardCases: [WallStandardCase]
	# Get all Door objects
	allDoors: [Door]
	# Get all PropertySetDefinition objects
	allPropertySets: [PropertySet]
	# Get all StairFlight objects
	allStairFlights: [StairFlight]
	getTestPolyline: Polyline
	getTestExtrudedAreaSolid: ExtrudedAreaSolid
	getTestRepresentationItem: RepresentationItem
	getTestArbitraryClosedProfileDef: ArbitraryClosedProfileDef
	getTestPropertySingleValue: PropertySingleValue
	getTestValue: Value
	getTestBooleanValue: BooleanValue
	getTestRealValue: RealValue
}

schema {
  query: Query
}